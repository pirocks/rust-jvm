use itertools::Itertools;
use crate::{JVMString, PossiblyJVMString};

const ZEROES: &str = "0٠۰߀०০੦૦୦௦౦೦൦๐໐༠၀႐០᠐᥆᧐᭐᮰᱀᱐꘠꣐꤀꩐０";
const WHITESPACE_TABLE: &str = " 　\r\u{0085}   　\u{2029}\u{000b}　   　 \t      　 　　\u{2028}\n 　";

#[test]
pub fn cursed_strings_round_trip() {
    for cursed_string in [ZEROES, WHITESPACE_TABLE] {
        let jvm_string = JVMString::from_regular_string(cursed_string);
        assert_eq!(jvm_string.to_string().unwrap().as_str(), cursed_string);
        assert_eq!(jvm_string.to_wtf8().as_str().unwrap(), cursed_string);
    }
}

const ZERO_BYTES: &[u8] = &[0b00110000u8, 0b11011001u8, 0b10100000u8, 0b11011011u8, 0b10110000u8, 0b11011111u8, 0b10000000u8, 0b11100000u8, 0b10100101u8, 0b10100110u8, 0b11100000u8, 0b10100111u8, 0b10100110u8, 0b11100000u8, 0b10101001u8, 0b10100110u8, 0b11100000u8, 0b10101011u8, 0b10100110u8, 0b11100000u8, 0b10101101u8, 0b10100110u8, 0b11100000u8, 0b10101111u8, 0b10100110u8, 0b11100000u8, 0b10110001u8, 0b10100110u8, 0b11100000u8, 0b10110011u8, 0b10100110u8, 0b11100000u8, 0b10110101u8, 0b10100110u8, 0b11100000u8, 0b10111001u8, 0b10010000u8, 0b11100000u8, 0b10111011u8, 0b10010000u8, 0b11100000u8, 0b10111100u8, 0b10100000u8, 0b11100001u8, 0b10000001u8, 0b10000000u8, 0b11100001u8, 0b10000010u8, 0b10010000u8, 0b11100001u8, 0b10011111u8, 0b10100000u8, 0b11100001u8, 0b10100000u8, 0b10010000u8, 0b11100001u8, 0b10100101u8, 0b10000110u8, 0b11100001u8, 0b10100111u8, 0b10010000u8, 0b11100001u8, 0b10101101u8, 0b10010000u8, 0b11100001u8, 0b10101110u8, 0b10110000u8, 0b11100001u8, 0b10110001u8, 0b10000000u8, 0b11100001u8, 0b10110001u8, 0b10010000u8, 0b11101010u8, 0b10011000u8, 0b10100000u8, 0b11101010u8, 0b10100011u8, 0b10010000u8, 0b11101010u8, 0b10100100u8, 0b10000000u8, 0b11101010u8, 0b10101001u8, 0b10010000u8, 0b11101111u8, 0b10111100u8, 0b10010000u8];


#[test]
pub fn zero_bytes_match() {
    let possibly_str = PossiblyJVMString::new(ZERO_BYTES.iter().cloned().collect_vec());
    assert_eq!(possibly_str.validate(false).unwrap().to_string_validated(), ZEROES);
}


const CURSED_BYTES: &[u8] = &[0b11000000,0b10000000,0b01111111,0b11000010,0b10101101,0b11011000,0b10000000,0b11011000,0b10011100,0b11011011,0b10011101,0b11011100,0b10001111,0b11100001,0b10011010,0b10000000,0b11100001,0b10100000,0b10001110,0b11100010,0b10000000,0b10000000,0b11100010,0b10000000,0b10101000,0b11100010,0b10000001,0b10011111,0b11100010,0b10000001,0b10100110,0b11100010,0b10000001, 0b10100111,0b11100010,0b10000001,0b10101000,0b11100010, 0b10000001, 0b10101001,0b11100010, 0b10000001, 0b10101010, 0b11100011, 0b10000000,0b10000000, 0b11101101, 0b10100000, 0b10000000, 0b11101111,0b10111011, 0b10111111, 0b11101111, 0b10111111, 0b10111001,0b11101111, 0b10111111, 0b10111010];

#[test]
pub fn test_another() {
    let possibly_str = PossiblyJVMString::new(CURSED_BYTES.iter().cloned().collect_vec());
    let string = possibly_str.to_regular_utf8(true).unwrap().unwrap_wtf8();
    for x in string.code_points() {
        print!("{} ", x.to_u32() as u32);
    }
}